
## Часть 1: Оценка сложности (Big O)

*Твоя задача: определить сложность каждого фрагмента кода (например, O(1), O(n), O(n^2))*

### Примеры для анализа:

1. **Простой вывод:**
```python
print("Hello, World!")
```


2. **Одиночный цикл:**
```python
for i in range(n):
    print(i)
```


3. **Вложенные циклы:**
```python
for i in range(n):
    for j in range(n):
        print(i + j)
```


4. **Два цикла подряд:**
```python
for i in range(n):
    print(i)
for j in range(n):
    print(j)
```


5. **Цикл с шагом умножения (важно!):**
```python
i = 1
while i < n:
    print(i)
    i *= 2
```


6. **Вложенный цикл с разными переменными:**
```python
for i in range(n):
    for j in range(m):
        print(i, j)
```


7. **Трехэтажный цикл:**
```python
for i in range(n):
    for j in range(n):
        for k in range(n):
            print(i, j, k)
```


8. **Доступ по индексу:**
```python
my_list = [1, 2, 3, 4, 5]
x = my_list[0]
```


9. **Поиск в словаре (в среднем):**
```python
my_dict = {"a": 1, "b": 2}
print(my_dict["a"])
```


10. **Рекурсивные числа Фибоначчи (наивные):**
```python
def fib(n):
    if n <= 1: return n
    return fib(n-1) + fib(n-2)
```

---

## Часть 2: Задачи на бинарный поиск

### Задача №1: "Угадай число" (Классика)

**Условие:** У тебя есть отсортированный список из 1000 элементов. Напиши функцию `binary_search(arr, target)`, которая найдет индекс числа `target`. Если числа нет в списке, верни `-1`.

* **Входные данные:** `arr = [1, 3, 5, 7, 9, 11, 13, 15]`, `target = 7`
* **Ожидаемый ответ:** `3`

### Задача №2: "Поиск вставки"

**Условие:** Дан отсортированный массив и число. Если число есть в массиве, верни его индекс. Если его нет, верни индекс, куда его **нужно было бы вставить**, чтобы массив остался отсортированным.

* **Входные данные:** `arr = [1, 3, 5, 6]`, `target = 5` -> **Ответ:** `2`
* **Входные данные:** `arr = [1, 3, 5, 6]`, `target = 2` -> **Ответ:** `1`
